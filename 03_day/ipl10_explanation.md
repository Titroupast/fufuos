# ipl10.nas 代码逐行详解

这是一个引导扇区程序（IPL），它的主要功能是从软盘中加载操作系统的核心文件到内存，并开始执行它。它将被 BIOS 加载到内存的 `0x7c00` 地址处。

---

### 1. 常量定义与程序起始地址

```nasm
; haribote-ipl
; TAB=4

CYLS	EQU		10				; 声明CYLS=10

		ORG		0x7c00			; 指明程序装载地址
```

*   **第 1-2 行**: 注释，说明文件名和代码格式。
*   **第 4 行**: `CYLS EQU 10`
    *   定义一个名为 `CYLS` 的常量，其值为 10。`CYLS` 是 Cylinders（柱面）的缩写。这表示该程序将从软盘读取 10 个柱面的数据。
*   **第 6 行**: `ORG 0x7c00`
    *   `ORG` 是 Origin（起始地址）的缩写。这行代码告诉编译器，本程序的机器码将被加载到内存的 `0x7c00` 地址处。这是 BIOS 加载引导扇区的标准内存地址，非常重要。

---

### 2. FAT12 软盘格式信息（BPB - BIOS Parameter Block）

这部分不是可执行代码，而是描述软盘格式的数据结构。BIOS 和操作系统需要通过读取这些信息来了解磁盘的布局。

```nasm
; 标准FAT12格式软盘专用的代码 Stand FAT12 format floppy code

		JMP		entry
		DB		0x90
		DB		"HARIBOTE"		; 启动扇区名称（8字节）
		DW		512				; 每个扇区（sector）大小（必须512字节）
		DB		1				; 簇（cluster）大小（必须为1个扇区）
		DW		1				; FAT起始位置（一般为第一个扇区）
		DB		2				; FAT个数（必须为2）
		DW		224				; 根目录大小（一般为224项）
		DW		2880			; 该磁盘大小（必须为2880扇区1440*1024/512）
		DB		0xf0			; 磁盘类型（必须为0xf0）
		DW		9				; FAT的长度（必??9扇区）
		DW		18				; 一个磁道（track）有几个扇区（必须为18）
		DW		2				; 磁头数（必??2）
		DD		0				; 不使用分区，必须是0
		DD		2880			; 重写一次磁盘大小
		DB		0,0,0x29		; 意义不明（固定）
		DD		0xffffffff		; （可能是）卷标号码
		DB		"HARIBOTEOS "	; 磁盘的名称（必须为11字?，不足填空格）
		DB		"FAT12   "		; 磁盘格式名称（必??8字?，不足填空格）
		RESB	18				; 先空出18字节
```

*   **第 10 行**: `JMP entry`
    *   一条无条件跳转指令，跳过后面的数据区，直接到达名为 `entry` 的代码标签处开始执行。
*   **第 11 行**: `DB 0x90`
    *   一个 `NOP` (No Operation) 空操作指令，用于占位。
*   **第 12-28 行**: 这些都是标准的 FAT12 文件系统格式参数。
    *   `DB "HARIBOTE"`: OEM 厂商标识。
    *   `DW 512`: 每个扇区的字节数。
    *   `DB 1`: 每个簇的扇区数。
    *   `DW 1`: 保留扇区数。
    *   `DB 2`: FAT表的数量。
    *   `DW 224`: 根目录区能容纳的最大文件数。
    *   `DW 2880`: 总扇区数 (对于1.44MB软盘, 1440 * 1024 / 512 = 2880)。
    *   `DB 0xf0`: 介质类型，`0xf0` 代表1.44MB软盘。
    *   `DW 9`: 每个FAT表占用的扇区数。
    *   `DW 18`: 每个磁道（柱面上的某一圈）的扇区数。
    *   `DW 2`: 磁头数（代表盘面数）。
    *   等等...
*   **第 29 行**: `RESB 18`
    *   `RESB` (Reserve Bytes) 指令，在此处保留18个字节的空间。

---

### 3. 程序主体 - 初始化与磁盘读取

```nasm
entry:
		MOV		AX,0			; 初始化寄存器
		MOV		SS,AX
		MOV		SP,0x7c00
		MOV		DS,AX

; 读取磁盘

		MOV		AX,0x0820
		MOV		ES,AX
		MOV		CH,0			; 柱面0
		MOV		DH,0			; 磁头0
		MOV		CL,2			; 扇区2
```

*   **第 33 行**: `entry:`
    *   代码执行的入口标签。
*   **第 34-37 行**: 初始化段寄存器。
    *   `MOV SS, AX` (SS=0), `MOV SP, 0x7c00`: 设置堆栈段和堆栈指针。堆栈将从 `0x7c00` 开始向下增长。
    *   `MOV DS, AX` (DS=0): 设置数据段寄存器。
*   **第 41-42 行**: 设置数据加载的目标内存地址。
    *   `MOV AX, 0x0820`, `MOV ES, AX`: 将 `ES` (附加段寄存器) 设置为 `0x0820`。数据将被加载到 `ES:BX` 指定的地址，即 `0x0820:0000`，物理地址为 `0x8200`。
*   **第 43-45 行**: 设置起始读取位置。
    *   `CH=0`: 从第0个柱面开始。
    *   `DH=0`: 从第0个磁头开始。
    *   `CL=2`: 从第2个扇区开始。跳过第1个扇区，因为第1个扇区就是引导扇区本身。

---

### 4. 磁盘读取循环与错误重试

```nasm
readloop:
		MOV		SI,0			; 记录失败次数寄存器

retry:
		MOV		AH,0x02			; AH=0x02 : 读入磁盘
		MOV		AL,1			; 1个扇区
		MOV		BX,0
		MOV		DL,0x00			; A驱动器
		INT		0x13			; 调用磁盘BIOS
		JNC		next			; 没出错则跳转到next
		ADD		SI,1			; 往SI加1
		CMP		SI,5			; 比较SI与5
		JAE		error			; SI >= 5 跳转到error
		MOV		AH,0x00
		MOV		DL,0x00			; A驱动器
		INT		0x13			; 重置驱动器
		JMP		retry
```

*   **第 47 行**: `readloop:`
    *   读取磁盘的主循环标签。
*   **第 48-63 行**: 调用 BIOS 中断 `0x13` 来读取磁盘，并包含重试逻辑。
    *   `MOV AH, 0x02`: 设置功能号为2（读扇区）。
    *   `MOV AL, 1`: 读取1个扇区。
    *   `MOV BX, 0`: 数据存放到 `ES:BX`，即 `0x8200` 开始的地址。
    *   `MOV DL, 0x00`: 驱动器号0，代表A驱动器（软驱）。
    *   `INT 0x13`: 调用 BIOS 磁盘服务。
    *   `JNC next`: `JNC` (Jump if No Carry)，如果进位标志位为0（表示没有发生错误），则跳转到 `next`。
    *   如果出错，则会执行 `ADD SI,1` 增加失败计数器。如果失败次数小于5次 (`CMP SI,5`, `JAE error`)，则会重置驱动器 (`MOV AH,0x00`, `INT 0x13`) 并跳转到 `retry` 重新尝试。如果失败5次或以上，则跳转到 `error`。

---

### 5. 更新地址，准备读取下一个扇区

```nasm
next:
		MOV		AX,ES			; 把内存地址后移0x200（512/16十六进制转换）
		ADD		AX,0x0020
		MOV		ES,AX			; ADD ES,0x020因为没有ADD ES，只能通过AX进行
		ADD		CL,1			; 往CL里面加1
		CMP		CL,18			; 比较CL与18
		JBE		readloop		; CL <= 18 跳转到readloop
		MOV		CL,1
		ADD		DH,1
		CMP		DH,2
		JB		readloop		; DH < 2 跳转到readloop
		MOV		DH,0
		ADD		CH,1
		CMP		CH,CYLS
		JB		readloop		; CH < CYLS 跳转到readloop
```

*   **第 64 行**: `next:`
    *   成功读取一个扇区后，执行此处的代码。
*   **第 65-67 行**: 更新内存加载地址。
    *   每个扇区512字节（`0x200`字节）。要将加载地址向后移动512字节。在分段内存模式下，段寄存器 `ES` 增加 `0x20` 等效于物理地址增加 `0x200` (`0x20 * 16 = 512`)。
*   **第 68-78 行**: 更新磁盘读取位置（扇区号 `CL`，磁头号 `DH`，柱面号 `CH`）。
    *   首先增加扇区号 `CL`。如果 `CL` 超过了18（每个磁道的最大扇区数），则将 `CL` 重置为1，并增加磁头号 `DH`。
    *   如果 `DH` 超过了2（磁头数），则将 `DH` 重置为0，并增加柱面号 `CH`。
    *   最后检查柱面号 `CH` 是否小于 `CYLS`（我们定义的常量10）。如果小于10，则跳转回 `readloop` 继续读取。

---

### 6. 加载完成与执行跳转

```nasm
; 读取完毕，跳转到haribote.sys执行！
		MOV		[0x0ff0],CH		; IPLがどこまで読んだのかをメモ
		JMP		0xc200
```

*   当所有指定的柱面都读取完毕后，循环结束，执行到这里。
*   **第 81 行**: `MOV [0x0ff0], CH`
    *   将最后读取的柱面号保存到内存地址 `0x0ff0` 处。这是一种向即将执行的操作系统内核传递信息的方式。
*   **第 82 行**: `JMP 0xc200`
    *   跳转到内存地址 `0xc200` 处。这是假设操作系统的核心代码 (`bootpack.c` 编译后的代码) 已经被加载到了这个地址。CPU 将从 `0xc200` 开始执行新的指令。

---

### 7. 错误处理与程序结束

```nasm
error:
		MOV		SI,msg

putloop:
		MOV		AL,[SI]
		ADD		SI,1			; 给SI加1
		CMP		AL,0
		JE		fin
		MOV		AH,0x0e			; 显示一个文字
		MOV		BX,15			; 指定字符颜色
		INT		0x10			; 调用显卡BIOS
		JMP		putloop

fin:
		HLT						; 让CPU停止，等待指令
		JMP		fin				; 无限循环

msg:
		DB		0x0a, 0x0a		; 换行两次
		DB		"load error"
		DB		0x0a			; 换行
		DB		0

		RESB	0x7dfe-$		; 填写0x00直到0x001fe

		DB		0x55, 0xaa
```

*   **第 84 行**: `error:`
    *   如果读取磁盘失败次数过多，程序会跳转到这里。
*   **第 85-95 行**: 在屏幕上显示错误信息 "load error"。
    *   它通过循环 (`putloop`) 和 BIOS `INT 0x10` 中断（视频服务）逐个字符地打印 `msg` 标签处定义的字符串。
*   **第 97-99 行**: `fin:`
    *   程序结束。`HLT` (Halt) 指令让 CPU 停止工作，`JMP fin` 是一个死循环，以防 `HLT` 被意外唤醒。
*   **第 101-105 行**: `msg:`
    *   定义了要显示的错误信息字符串，以 `0` 结尾。`0x0a` 是换行符。
*   **第 107 行**: `RESB 0x7dfe-$`
    *   `$` 代表当前地址。这行代码的作用是用 `0x00` 填充当前位置到 `0x7dfe` 之间的所有字节。这是为了确保引导扇区的大小恰好是512字节。
*   **第 109 行**: `DB 0x55, 0xaa`
    *   这是**引导扇区签名**。BIOS 通过检查引导扇区的最后两个字节是否为 `0x55` 和 `0xaa` 来判断这个扇区是否是可启动的。如果不是这两个值，BIOS 将认为该磁盘不可引导。
