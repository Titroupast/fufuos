### 🎹 键盘指令的奇妙旅程 (以按下 'A' 键为例)



整个过程可以分为 6 个步骤，完美展现了 **“加速中断处理”** 和 **“FIFO 缓冲区”** 的威力！



#### 💖 **阶段一：等待与触发 (硬件世界)**



| **步骤**   | **角色**               | **动作描述**                                                 | **Day 7 核心要点**                                           |
| ---------- | ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Step 1** | **主程序 `HariMain`**  | 在主循环中，程序执行 `io_stihlt()`。 CPU **开放中断 (`STI`)** 后，立即进入**低功耗休眠 (`HLT`)** 模式，等待事件发生。 | **极度节能且高效地等待**：如果什么都没发生，CPU 就安静地休息。 |
| **Step 2** | **键盘**               | 你轻轻按下了键盘上的 **'A' 键**。键盘硬件立即将代表“A 键被按下”的**按键编码（扫描码）**（例如 `0x1E`）发送给键盘控制电路。 | **按键编码**：每个按键都有一个独特的十六进制身份。           |
| **Step 3** | **键盘控制电路 / PIC** | 键盘控制电路通过 **IRQ-1**（中断请求线 1）向 **PIC0**（主 PIC）发送一个电信号。PIC0 接收到信号后，立即**暂停**正在休眠的 CPU。 | **中断请求**：信号一旦发出，CPU 必须立即放下手头工作（即使在休眠）。 |

------



#### 🚀 **阶段二：中断处理与加速 (汇编与 C 语言)**



| **步骤**     | **角色**                            | **动作描述**                                                 | **Day 7 核心要点**                                           |
| ------------ | ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Step 4**   | **CPU / 汇编**                      | CPU 被唤醒。它保存了当前所有重要的工作状态（寄存器），然后根据 **IRQ-1** 查表，找到对应的汇编中断处理函数入口，并跳转过去。 | **上下文保存**：确保中断处理完毕后，CPU 能完美地回到 Step 1 被暂停的地方。 |
| **Step 5**   | **C 语言中断处理 (`inthandler21`)** | CPU 开始执行我们编写的 C 函数 `inthandler21`。**这是今天优化的重点！** | **加速处理**：只做两件必须在中断期间完成的事。               |
| **Step 5.1** | **通知 PIC**                        | `io_out8(PIC0_OCW2, 0x61);`：立即向 PIC0 发送信号，告诉它：“**IRQ-1 我已经处理了，请继续监视下一次中断！**” | **及时响应**：尽快释放 PIC，防止新的键盘输入被阻塞。         |
| **Step 5.2** | **获取数据**                        | `data = io_in8(PORT_KEYDAT);`：CPU 立刻从数据端口 (`0x60`) 读取按键编码（`0x1E`）。 | **硬件交互**：端口 `0x60` 是键盘/鼠标数据的唯一出口。        |
| **Step 5.3** | **存入 FIFO**                       | `fifo8_put(&keyfifo, data);`：将 `0x1E` 快速存入 **键盘的循环 FIFO 缓冲区** 中，并更新 `next_w`（写入位置）。 | **消除阻塞**：数据迅速存入缓冲区，**中断处理函数立即结束并返回**。耗时操作（如显示字符）被成功避免！ |

------



#### 🖥️ **阶段三：主程序取出与显示 (软件应用)**



| **步骤**   | **角色**              | **动作描述**                                                 | **Day 7 核心要点**                                           |
| ---------- | --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Step 6** | **主程序 `HariMain`** | CPU 从中断中返回，回到 Step 1 暂停的地方，继续执行 `io_stihlt()` 循环。 | **回归主线**：CPU 不再被键盘事件困扰。                       |
| **Step 7** | **主程序循环**        | 在循环中，`HariMain` 检查 `if (fifo8_status(&keyfifo) > 0)`。发现 FIFO 中有数据！ | **主动查询**：主程序是**主动**去缓冲区拿数据的，而不是被动地等待中断。 |
| **Step 8** | **取出与显示**        | `data = fifo8_get(&keyfifo);`：从 FIFO 中取出 `0x1E`，并更新 `next_r`（读出位置）。然后，程序将 `0x1E` 转换为字符 **'A'**，并将其画到屏幕上。 | **FIFO 优势**：取出数据不会影响键盘输入，因为输入和输出是**完全解耦**的！ |

------



### 鼠标指令 (IRQ-12) 的小小不同



鼠标指令的流程几乎和键盘一模一样，只是在 **Step 5.1 通知 PIC** 的时候，需要多一个步骤：

- **键盘 (IRQ-1):** 只需通知 **PIC0** (`0x61`)。
- **鼠标 (IRQ-12):** 由于 IRQ-12 连接在 **PIC1**（从 PIC）上，所以需要**先通知 PIC1** 受理完毕 (`0x64`)，**再通知 PIC0** 负责从 PIC 连接的那个端口受理完毕 (`0x62`)。

**相同之处是：** 数据也是从 **`PORT_KEYDAT` (0x60)** 端口读取，并存入 **`mousefifo`** 缓冲区！

