# `dsctbl.c` 文件解析

`dsctbl.c` 是一个至关重要的文件，它负责设置处理器的描述符表：即全局描述符表 (GDT) 和中断描述符表 (IDT)。这些表对于保护模式下的操作至关重要，它们控制着内存访问权限和中断处理流程。

## `init_gdtidt()`

这是该文件中的核心函数，它按顺序完成了 GDT 和 IDT 的初始化。

### GDT 初始化
1.  **清空 GDT**: 代码首先遍历整个 GDT 内存区域并将其全部置零。这确保了 GDT 中不包含任何陈旧的数据。
2.  **设置段描述符**: 接着，它设置了两个关键的段描述符：
    -   **段 1**: 一个覆盖全部 4GB 地址空间的数据段。这创建了一个“平坦内存模型”，使得整个可寻址内存可以被当作一个连续的数据块来访问。
    -   **段 2**: 一个代码段，它精确地映射到操作系统代码 (`bootpack`) 被加载到的内存区域。CPU 将从这个段执行代码。
3.  **加载 GDTR**: 最后，它调用 `load_gdtr` 函数，将 GDT 的地址和大小加载到 CPU 的 GDTR 寄存器中。从这一刻起，CPU 将使用这个 GDT 来进行所有的内存访问控制。

### IDT 初始化
1.  **清空 IDT**: 与 GDT 类似，IDT 所在的内存区域也被完全清零。
2.  **设置中断门**: 接下来，代码为特定的硬件中断设置了门描述符。一个门描述符告诉 CPU 在收到特定中断时应该跳转到哪里去执行处理代码。
    -   `idt + 0x21`: 映射到 `asm_inthandler21`，用于处理键盘中断 (IRQ 1)。
    -   `idt + 0x27`: 映射到 `asm_inthandler27`，用于处理 IRQ 7。
    -   `idt + 0x2c`: 映射到 `asm_inthandler2c`，用于处理鼠标中断 (IRQ 12)。
    调用中的选择子 `2 * 8` 告诉 CPU 在执行中断处理程序时，应该使用 GDT 中索引为 2 的代码段。
3.  **加载 IDTR**: 最后，它调用 `load_idtr` 函数，将 IDT 的地址和大小加载到 CPU 的 IDTR 寄存器中。现在，当一个中断发生时，CPU 就会使用这张表来查找对应的处理程序。

## 辅助函数

### `set_segmdesc()`
这个函数是一个工具函数，用于方便地填充 `SEGMENT_DESCRIPTOR` 结构体的字段。由于段描述符的格式非常复杂且是位压缩的，这个函数将设置段的 `base` (基地址)、`limit` (大小) 和 `ar` (访问权限) 的复杂过程抽象了出来。

### `set_gatedesc()`
这是另一个工具函数，用于填充 `GATE_DESCRIPTOR` 结构体的字段。它通过接收处理程序的 `offset` (地址)、`selector` (代码段选择子) 和 `ar` (访问权限) 参数，简化了创建中断门的过程。
